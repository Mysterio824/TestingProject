{
	"info": {
		"_postman_id": "3e236468-fbb0-4a1c-807a-e9bf80ac9cab",
		"name": "HW07",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "42612543"
	},
	"item": [
		{
			"name": "Sign-In",
			"item": [
				{
					"name": "Sign-In",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Identify the test\r",
									"const id = pm.iterationData.get('TestCaseID') || pm.iterationData.get('TestCaseId') || '';\r",
									"const title = pm.iterationData.get('Title') || pm.iterationData.get('Description') || '';\r",
									"\r",
									"// Parse ER: \"Status:201\" / \"StatusCode:201\" / \"field:msg|field:msg1/msg2\"\r",
									"const er = (pm.iterationData.get('ER') || '').trim();\r",
									"const parts = er ? er.split('|').map(s => s.trim()).filter(Boolean) : [];\r",
									"\r",
									"const jsonText = pm.response.text();\r",
									"let json;\r",
									"try { json = pm.response.json(); } catch (_) { json = null; }\r",
									"\r",
									"let expectedStatus = null;\r",
									"const fieldExpectations = []; // { field, expectedList[] }\r",
									"\r",
									"parts.forEach(p => {\r",
									"  const m = p.match(/^([^:]+)\\s*:\\s*(.+)$/);\r",
									"  if (!m) return;\r",
									"  const key = m[1].toLowerCase();\r",
									"  const value = m[2];\r",
									"\r",
									"  if (key === 'status' || key === 'statuscode') {\r",
									"    const code = parseInt(value, 10);\r",
									"    if (!Number.isNaN(code)) expectedStatus = code;\r",
									"  } else {\r",
									"    const expectedList = value.split(/[\\/\\\\]/).map(s => s.trim()).filter(Boolean);\r",
									"    fieldExpectations.push({ field: key, expectedList });\r",
									"  }\r",
									"});\r",
									"\r",
									"// Status code (optional)\r",
									"if (expectedStatus !== null) {\r",
									"  pm.test(`[${id}] ${title} - status is ${expectedStatus}`, function () {\r",
									"    pm.response.to.have.status(expectedStatus);\r",
									"  });\r",
									"}\r",
									"\r",
									"// Collect candidate messages for a field from common response shapes\r",
									"function collectMessages(field) {\r",
									"  const candidates = [];\r",
									"\r",
									"  if (json && typeof json === 'object') {\r",
									"    if (json.errors && json.errors[field] !== undefined) candidates.push(json.errors[field]);\r",
									"    if (json[field] !== undefined) candidates.push(json[field]);\r",
									"    if (json.message && typeof json.message === 'object' && json.message[field] !== undefined) {\r",
									"      candidates.push(json.message[field]);\r",
									"    }\r",
									"    // Special handling for generic \"message\"\r",
									"    if (field === 'message') {\r",
									"      if (json.message !== undefined) candidates.push(json.message);\r",
									"      if (json.error && json.error.message !== undefined) candidates.push(json.error.message);\r",
									"    }\r",
									"  }\r",
									"\r",
									"  return candidates.flatMap(v => Array.isArray(v) ? v : [v]).map(v => String(v));\r",
									"}\r",
									"\r",
									"// Field/message assertions (all listed expectations must be present)\r",
									"fieldExpectations.forEach(({ field, expectedList }) => {\r",
									"  pm.test(`[${id}] ${title} - ${field} contains all expected (${expectedList.length})`, function () {\r",
									"    const messages = collectMessages(field);\r",
									"    const allFound = expectedList.every(exp =>\r",
									"      messages.some(msg => msg.includes(exp)) || jsonText.includes(exp)\r",
									"    );\r",
									"    pm.expect(allFound, `Expected ${field} to contain: ${JSON.stringify(expectedList)}. Got: ${JSON.stringify(messages)}`).to.be.true;\r",
									"  });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{ \"email\": \"{{Email}}\", \"password\": \"{{Password}}\" }",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{BASE_API_URL}}/users/login",
							"host": [
								"{{BASE_API_URL}}"
							],
							"path": [
								"users",
								"login"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Sign-Up",
			"item": [
				{
					"name": "Sign-Up",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Identify the test\r",
									"const id = pm.iterationData.get('TestCaseID') || pm.iterationData.get('TestCaseId') || '';\r",
									"const title = pm.iterationData.get('Title') || pm.iterationData.get('Description') || '';\r",
									"\r",
									"// Parse ER: \"Status:201\" / \"StatusCode:201\" / \"field:msg|field:msg1/msg2\"\r",
									"const er = (pm.iterationData.get('ER') || '').trim();\r",
									"const parts = er ? er.split('|').map(s => s.trim()).filter(Boolean) : [];\r",
									"\r",
									"const jsonText = pm.response.text();\r",
									"let json;\r",
									"try { json = pm.response.json(); } catch (_) { json = null; }\r",
									"\r",
									"let expectedStatus = null;\r",
									"const fieldExpectations = []; // { field, expectedList[] }\r",
									"\r",
									"parts.forEach(p => {\r",
									"  const m = p.match(/^([^:]+)\\s*:\\s*(.+)$/);\r",
									"  if (!m) return;\r",
									"  const key = m[1].toLowerCase();\r",
									"  const value = m[2];\r",
									"\r",
									"  if (key === 'status' || key === 'statuscode') {\r",
									"    const code = parseInt(value, 10);\r",
									"    if (!Number.isNaN(code)) expectedStatus = code;\r",
									"  } else {\r",
									"    const expectedList = value.split(/[\\/\\\\]/).map(s => s.trim()).filter(Boolean);\r",
									"    fieldExpectations.push({ field: key, expectedList });\r",
									"  }\r",
									"});\r",
									"\r",
									"// Status code (optional)\r",
									"if (expectedStatus !== null) {\r",
									"  pm.test(`[${id}] ${title} - status is ${expectedStatus}`, function () {\r",
									"    pm.response.to.have.status(expectedStatus);\r",
									"  });\r",
									"}\r",
									"\r",
									"// Collect candidate messages for a field from common response shapes\r",
									"function collectMessages(field) {\r",
									"  const candidates = [];\r",
									"\r",
									"  if (json && typeof json === 'object') {\r",
									"    if (json.errors && json.errors[field] !== undefined) candidates.push(json.errors[field]);\r",
									"    if (json[field] !== undefined) candidates.push(json[field]);\r",
									"    if (json.message && typeof json.message === 'object' && json.message[field] !== undefined) {\r",
									"      candidates.push(json.message[field]);\r",
									"    }\r",
									"    // Special handling for generic \"message\"\r",
									"    if (field === 'message') {\r",
									"      if (json.message !== undefined) candidates.push(json.message);\r",
									"      if (json.error && json.error.message !== undefined) candidates.push(json.error.message);\r",
									"    }\r",
									"  }\r",
									"\r",
									"  return candidates.flatMap(v => Array.isArray(v) ? v : [v]).map(v => String(v));\r",
									"}\r",
									"\r",
									"// Field/message assertions (all listed expectations must be present)\r",
									"fieldExpectations.forEach(({ field, expectedList }) => {\r",
									"  pm.test(`[${id}] ${title} - ${field} contains all expected (${expectedList.length})`, function () {\r",
									"    const messages = collectMessages(field);\r",
									"    const allFound = expectedList.every(exp =>\r",
									"      messages.some(msg => msg.includes(exp)) || jsonText.includes(exp)\r",
									"    );\r",
									"    pm.expect(allFound, `Expected ${field} to contain: ${JSON.stringify(expectedList)}. Got: ${JSON.stringify(messages)}`).to.be.true;\r",
									"  });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"first_name\": \"{{FirstName}}\",\r\n  \"last_name\": \"{{LastName}}\",\r\n  \"dob\": \"{{Dob}}\",\r\n  \"address\": \"{{Address}}\",\r\n  \"postcode\": \"{{Postcode}}\",\r\n  \"city\": \"{{City}}\",\r\n  \"state\": \"{{State}}\",\r\n  \"country\": \"{{Country}}\",\r\n  \"phone\": \"{{Phone}}\",\r\n  \"email\": \"{{Email}}\",\r\n  \"password\": \"{{Password}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{BASE_API_URL}}/users/register",
							"host": [
								"{{BASE_API_URL}}"
							],
							"path": [
								"users",
								"register"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Add-Product",
			"item": [
				{
					"name": "Add-Products",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Identify the test\r",
									"const id = pm.iterationData.get('TestCaseID') || pm.iterationData.get('TestCaseId') || '';\r",
									"const title = pm.iterationData.get('Title') || pm.iterationData.get('Description') || '';\r",
									"\r",
									"// Parse ER: \"Status:201\" / \"StatusCode:201\" / \"field:msg|field:msg1/msg2\"\r",
									"const er = (pm.iterationData.get('ER') || '').trim();\r",
									"const parts = er ? er.split('|').map(s => s.trim()).filter(Boolean) : [];\r",
									"\r",
									"const jsonText = pm.response.text();\r",
									"let json;\r",
									"try {\r",
									"    // Use JSON.parse with a reviver to handle large integers as BigInt\r",
									"    json = JSON.parse(jsonText, (key, value) => {\r",
									"        // Adjust 'id' or other field names as needed for your API\r",
									"        if (typeof value === 'string' && /^\\d+$/.test(value) && value.length > 15) {\r",
									"            try {\r",
									"                return BigInt(value);\r",
									"            } catch (e) {\r",
									"                return value; // Fallback to string if BigInt fails\r",
									"            }\r",
									"        }\r",
									"        return value;\r",
									"    });\r",
									"} catch (_) {\r",
									"    json = null;\r",
									"}\r",
									"\r",
									"// Store expected status code and field expectations\r",
									"let expectedStatus = null;\r",
									"const fieldExpectations = []; // { field, expectedList[] }\r",
									"\r",
									"parts.forEach(p => {\r",
									"    const m = p.match(/^([^:]+)\\s*:\\s*(.+)$/);\r",
									"    if (!m) return;\r",
									"    const key = m[1].toLowerCase();\r",
									"    const value = m[2];\r",
									"\r",
									"    if (key === 'status' || key === 'statuscode') {\r",
									"        const code = parseInt(value, 10);\r",
									"        if (!Number.isNaN(code)) expectedStatus = code;\r",
									"    } else {\r",
									"        const expectedList = value.split(/[\\/\\\\]/).map(s => s.trim()).filter(Boolean);\r",
									"        fieldExpectations.push({ field: key, expectedList });\r",
									"    }\r",
									"});\r",
									"\r",
									"// Status code assertion (unchanged)\r",
									"if (expectedStatus !== null) {\r",
									"    pm.test(`[${id}] ${title} - status is ${expectedStatus}`, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									"\r",
									"// Collect candidate messages for a field from common response shapes\r",
									"function collectMessages(field) {\r",
									"    const candidates = [];\r",
									"\r",
									"    if (json && typeof json === 'object') {\r",
									"        if (json.errors && json.errors[field] !== undefined) {\r",
									"            candidates.push(json.errors[field]);\r",
									"        }\r",
									"        if (json[field] !== undefined) {\r",
									"            candidates.push(json[field]);\r",
									"        }\r",
									"        if (json.message && typeof json.message === 'object' && json.message[field] !== undefined) {\r",
									"            candidates.push(json.message[field]);\r",
									"        }\r",
									"        // Special handling for generic \"message\"\r",
									"        if (field === 'message') {\r",
									"            if (json.message !== undefined) candidates.push(json.message);\r",
									"            if (json.error && json.error.message !== undefined) candidates.push(json.error.message);\r",
									"        }\r",
									"    }\r",
									"\r",
									"    // Convert all values to strings, handling BigInt explicitly\r",
									"    return candidates.flatMap(v => Array.isArray(v) ? v : [v]).map(v => {\r",
									"        if (typeof v === 'bigint') return v.toString();\r",
									"        return String(v);\r",
									"    });\r",
									"}\r",
									"\r",
									"// Field/message assertions (all listed expectations must be present)\r",
									"fieldExpectations.forEach(({ field, expectedList }) => {\r",
									"    pm.test(`[${id}] ${title} - ${field} contains all expected (${expectedList.length})`, function () {\r",
									"        const messages = collectMessages(field);\r",
									"        const allFound = expectedList.every(exp =>\r",
									"            messages.some(msg => msg.includes(exp)) || jsonText.includes(exp)\r",
									"        );\r",
									"        pm.expect(allFound, `Expected ${field} to contain: ${JSON.stringify(expectedList)}. Got: ${JSON.stringify(messages)}`).to.be.true;\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{Name}}\",\r\n  \"description\": \"{{DescriptionText}}\",\r\n  \"price\": \"{{Price}}\",\r\n  \"category_id\": \"{{Category}}\",\r\n  \"brand_id\": \"{{Brand}}\",\r\n  \"product_image_id\": \"{{ProductImageId}}\",\r\n  \"is_location_offer\": \"{{IsLocationOffer}}\",\r\n  \"is_rental\": \"{{IsRental}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{BASE_API_URL}}/products",
							"host": [
								"{{BASE_API_URL}}"
							],
							"path": [
								"products"
							]
						}
					},
					"response": []
				}
			]
		}
	]
}